---
title: "Charville *et al* (Stem Cell Reports, 2015) RNA-Seq Data Re-Analysis"
author: "Joanna Dreux"
date: "March 14, 2016"
output: 
  html_document: 
    toc: yes
---

# Aims & Preliminary Steps
This document describes the R code I used for re-analysis of RNA-Seq data from the Charville *et al* paper published in Stem Cell Reports: [Ex Vivo Expansion and In Vivo Self-Renewal of Human Muscle Stem Cells](http://www.cell.com/stem-cell-reports/abstract/S2213-6711(15)00238-6).

This analysis was carried out both as a practice exercise, and to obtain the complete list of results from this experiment. The original paper only describes the top ~100 differentially expressed genes in each condition.

This R code picks up after the reads have been aligned to the genome, and the features counted.
Briefly, the sequencing files were obtained from the European Nucleotide Archive (ENA), reference [PRJEB10091](http://www.ebi.ac.uk/ena/data/view/PRJEB10091).
Following FastQC assesment of read quality, the paired reads were aligned to the hg38 assembly of the human genome using the STAR aligner. The features were counted using featureCount, and text files generated from the output. More details on this RNA-Seq pipeline can be found in a dedicated git repository [here](https://github.com/Joannacodes/RNA-Seq-pipeline-SGE-cluster).

# Setting up the data
This experiment comprised a "Quiescent" group and an "Activated" group, each with two replicates.
First, we want to get all the data into a format the DGEList constructor function of the EdgeR package will be able to read. We want a table of counts where the rows are features and the columns represent each sample.

```{r eval=TRUE}
samples <- c("A1","A2","Q1","Q2")

# a function to import each .txt file with the "htseq_counts" suffix into R:
read.sample <- function(sample.name) {
  file.name <- paste(sample.name, "_htseq_counts.txt", sep="")
  result <- read.delim(file.name, col.names=c("gene", "count"), sep="\t", colClasses=c("character", "numeric"), header = TRUE)
}

sample.1 <- read.sample(samples[1]) #import the first sample file
head(sample.1)
```
```{r eval=TRUE}
sample.2 <- read.sample(samples[2])

nrow(sample.1) == nrow(sample.2) #check row number is identical
all(sample.1$gene == sample.2$gene) # are all the values there?

#Now combine all the samples into one table
all.data <- sample.1
all.data <- cbind(sample.1, sample.2$count) #add the second row of sample.2 to the table

# now append the other two sample counts to the table
for (c in 3:length(samples)) {
  temp.data <- read.sample(samples[c])
  all.data <- cbind(all.data, temp.data$count)
}

#We now have a data frame with all the data in it:
colnames(all.data)[2:ncol(all.data)] <- samples #give the columns better names
head(all.data)
dim(all.data)

# Use the first column as row names instead
rownames(all.data) <- all.data$gene
all.data <- all.data[,-1]
head(all.data)
```

Now we have the data in the desired format, we can proceed with EdgeR.
# Constructing a DGEList object
```{r}
library(edgeR)
group <- c("Act","Act","Quies", "Quies") # define the group of each sample

cds <- DGEList( all.data , group = group ) # create the Digital Gene Expression object
dim(cds)
names(cds)
head(cds$counts)
cds$samples # a summary of the samples
```

# Filtering low and high expression reads
We want to exclude genes that are not expressed in all the replicates of one group. We also get rid of highly expressed genes (usually housekeeping genes that won't be very relevant to our pathway or DE analysis).
We compute the counts per million values for each gene in our DGEList object:
```{r}
countsPerMill <- cpm(cds)
summary(countsPerMill)

countCheck <- countsPerMill > 0.5 # genes that are expressed higher than 0.5 cpm
head(countCheck)
keep <- which(rowSums(countCheck) >= 2) #keep only genes for which this is TRUE in at least two samples
cds <- cds[keep,]
summary(cpm(cds)) #compare this to the original summary

countsPerMill <- cpm(cds) # recompute cpm 
summary(countsPerMill)
countCheck <- countsPerMill < 5000 #discard genes expressed above 5,000 cpm
keep <- which(rowSums(countCheck) >= 2)
cds <- cds[keep,]
summary(cpm(cds))
dim(cds) #down from 58k rows
```
If we want a visual on the reads we excluded we can look at the median log(cpm) on a histogram:
```{r}
cpm_log <- cpm(all.data, log = TRUE)
median_log2_cpm <- apply(cpm_log, 1, median)
hist(median_log2_cpm, col="blue", main="Discarded genes", xlim=c(-10,15))
expr_cutoff <- -1 #the log of 0.5
other_cutoff <- 3.7 #the (apprx.) log of 5000
abline(v = expr_cutoff, col = "red", lwd = 3)
abline(v = other_cutoff, col = "red", lwd = 3)
```

# Data visualization / overview
Principal component analysis and other functions like plotMDS are good to get an overview of the data/clustering. No surprises here. 
```{r}
cpm_log <- cpm(cds, log = TRUE)  #recalculate cpm after cleaning up data
heatmap(cor(cpm_log), main="Heatmap of Log CPM correlation", margins=c(5,5))
#Another method to view the relationships between samples is principal components 
#analysis (PCA).
pca <- prcomp(t(cpm_log), scale.=TRUE)
plot(pca$x[, 1], pca$x[, 2], pch = ".", cex=15, xlab = "PC1", ylab = "PC2", xlim=c(-120,150),ylim=c(-100,100), main="PCA for Rando")
text(pca$x[, 1], pca$x[, 2], labels = colnames(cpm_log), pos=1)
summary(pca)

#finally a variation on PCA with plotMDS
plotMDS(cds, top=500, main="plotMDS of top 100 genes", col=as.numeric(cds$samples$group), pch=24)
legend("bottomleft", as.character(unique(cds$samples$group)), col=1:2, pch=24)
```
# Normalization factors and dispersion
```{r}
cds<- calcNormFactors(cds)
cds$samples
```
To estimate dispersion, we need a design matrix. Here I defined it without a control group, so that  we wouldn't have an intersect column.
```{r}
design <- model.matrix(~0+group, data=cds$samples)
colnames(design) <- levels(cds$samples$group) #assign groups as colnames
design

cds <- estimateDisp(cds, design)
cds #now we have trended and tag wise dispersion in the object

plotBCV(cds, main="BCV plot")
```
# Exact test: Quiescent vs Activated
```{r}
et <- exactTest(cds, pair=c("Act","Quies"))
etp<- topTags(et, n=10)
etp
cds.DE <- decideTestsDGE(et, adjust.method="BH", p.value=0.05)
summary(cds.DE)
```
So 981 genes are downregulated and 1,345 are up-regulated in the Activated samples. We now use the function plotSmear to generate a plot of the tagwise log-fold-changes against log-cpm. DE tags are highlighted in red. The blue lines represent a log2 FC.

```{r}
de.genes <- rownames(cds)[as.logical(cds.DE)]
plotSmear(cds, de.tags = de.genes, main="Differential gene expression in Quiescent vs Activated")
abline(h = c(-2, 2), col = "blue")
```
#GLM testing for differential expression
There are no covariates that I know of in this experiment, this is just for practice.
```{r}
cds$samples$group <- relevel(cds$samples$group, ref="Quies") #relevel to get Quies as the ref group
design2 <- model.matrix(~group, data=cds$samples) #we use a new design with the Quiescent group as the reference level
design2

fit <- glmFit(cds, design2) #build the generalized linear model used for DE testing
lrt<- glmLRT(fit)
lrt.tbl <- topTags(lrt, n=10) # Make a table of results
lrt.tbl

cds.DE2 <- decideTestsDGE(lrt, adjust.method="BH", p.value = 0.05)
summary(cds.DE2)
de.genes2 <- rownames(cds)[as.logical(cds.DE2)]
plotSmear(cds, de.tags=de.genes2, main="DE genes using GLM testing")
abline(h = c(-2, 2), col = "blue")
```
#Top genes and Visualization
Hereâ€™s a closer look at the individual counts-per-million for the top genes. The top genes are somewhat consistent across the two replicates:
```{r}
top <- rownames(etp) #for glm
cpm(cds)[top,]
```
Below, we plot a histogram of log concentrations for the top 100 genes for each analysis.
```{r}
et.Tbl <- et$table 
exact.DE <- rownames(et.Tbl)[et.Tbl$PValue <= 0.05 ]
length(exact.DE) #how many genes are significantly DE
length(exact.DE)/nrow(et.Tbl) * 100 # Percentage of total genes
hist(et.Tbl[exact.DE[1:1000],"logCPM"], xlab="Log CPM", xlim=c(-5,15),col="red", freq=FALSE, main="Top 100 DE genes - exactTest")
lrt.Tbl <- lrt$table 
glm.DE <- rownames(lrt.Tbl)[lrt.Tbl$PValue <= 0.05 ]
length(glm.DE) #how many genes are significantly DE
length(glm.DE)/nrow(lrt.Tbl) * 100 # Percentage of total genes
hist(lrt.Tbl[glm.DE[1:1000],"logCPM"], xlab="Log CPM", xlim=c(-5,15),col="red", freq=FALSE, main="Top 100 DE genes - GLM")
```
Now how about a volcano plot:
```{r}
plot(et.Tbl$logFC, -log10(et.Tbl$PValue), pch=15, cex=0.2, xlab="Log FC", ylab="-log10 P-val") 
```
To go one step further and make this plot better, using ggplot2. Let's estimate which genes we find truly interesting,let's say p-value less than 0.05 and fold change greater than |1|.
```{r}
library("ggplot2")
sum(abs(et.Tbl$PValue <= 0.05 & et.Tbl$logFC >1)) #the number of genes above this cutoff
et.Tbl$threshold = as.factor(abs(et.Tbl$logFC) > 1 & et.Tbl$PValue < 0.05)
#Construct the plot
g = ggplot(data=et.Tbl, aes(x=logFC, y=-log10(PValue), colour=threshold)) + geom_point(alpha=0.4, size=1.75) + xlab("log2 fold change") + ylab("-log10 p-value")
g
```
#SessionInfo
```{r}
sessionInfo()
```
